{"ast":null,"code":"import { useRef, useState, useMemo, useCallback, useEffect } from 'react';\nimport debounce from 'lodash/debounce';\nimport throttle from 'lodash/throttle';\nconst patchResizeCallback = (resizeCallback, refreshMode, refreshRate, refreshOptions) => {\n  switch (refreshMode) {\n    case 'debounce':\n      return debounce(resizeCallback, refreshRate, refreshOptions);\n    case 'throttle':\n      return throttle(resizeCallback, refreshRate, refreshOptions);\n    default:\n      return resizeCallback;\n  }\n};\nfunction useResizeDetector({\n  skipOnMount = false,\n  refreshMode,\n  refreshRate = 1000,\n  refreshOptions,\n  handleWidth = true,\n  handleHeight = true,\n  targetRef,\n  observerOptions,\n  onResize\n} = {}) {\n  const skipResize = useRef(skipOnMount);\n  const [size, setSize] = useState({\n    width: undefined,\n    height: undefined\n  });\n  // we are going to use this ref to store the last element that was passed to the hook\n  const [refElement, setRefElement] = useState((targetRef === null || targetRef === void 0 ? void 0 : targetRef.current) || null);\n  // if targetRef is passed, we need to update the refElement\n  // we have to use setTimeout because ref get assigned after the hook is called\n  // in the future releases we are going to remove targetRef and force users to use ref returned by the hook\n  if (targetRef) {\n    setTimeout(() => {\n      if (targetRef.current !== refElement) {\n        setRefElement(targetRef.current);\n      }\n    }, 0);\n  }\n  // this is a memo that will be called every time the ref is changed\n  // This proxy will properly call setState either when the ref is called as a function or when `.current` is set\n  // we call setState inside to trigger rerender\n  const refProxy = useMemo(() => new Proxy(node => {\n    if (node !== refElement) {\n      setRefElement(node);\n    }\n  }, {\n    get(target, prop) {\n      if (prop === 'current') {\n        return refElement;\n      }\n      return target[prop];\n    },\n    set(target, prop, value) {\n      if (prop === 'current') {\n        setRefElement(value);\n      } else {\n        target[prop] = value;\n      }\n      return true;\n    }\n  }), [refElement]);\n  const shouldSetSize = useCallback((prevSize, nextSize) => {\n    if (prevSize.width === nextSize.width && prevSize.height === nextSize.height) {\n      // skip if dimensions haven't changed\n      return false;\n    }\n    if (prevSize.width === nextSize.width && !handleHeight || prevSize.height === nextSize.height && !handleWidth) {\n      // process `handleHeight/handleWidth` props\n      return false;\n    }\n    return true;\n  }, [handleWidth, handleHeight]);\n  const resizeCallback = useCallback(entries => {\n    if (!handleWidth && !handleHeight) return;\n    if (skipResize.current) {\n      skipResize.current = false;\n      return;\n    }\n    entries.forEach(entry => {\n      const {\n        width,\n        height\n      } = (entry === null || entry === void 0 ? void 0 : entry.contentRect) || {};\n      setSize(prevSize => {\n        if (!shouldSetSize(prevSize, {\n          width,\n          height\n        })) return prevSize;\n        return {\n          width,\n          height\n        };\n      });\n    });\n  }, [handleWidth, handleHeight, skipResize, shouldSetSize]);\n  const resizeHandler = useCallback(patchResizeCallback(resizeCallback, refreshMode, refreshRate, refreshOptions), [resizeCallback, refreshMode, refreshRate, refreshOptions]);\n  // on refElement change\n  useEffect(() => {\n    let resizeObserver;\n    if (refElement) {\n      resizeObserver = new window.ResizeObserver(resizeHandler);\n      resizeObserver.observe(refElement, observerOptions);\n    } else {\n      if (size.width || size.height) {\n        setSize({\n          width: undefined,\n          height: undefined\n        });\n      }\n    }\n    return () => {\n      var _a, _b, _c;\n      (_a = resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect) === null || _a === void 0 ? void 0 : _a.call(resizeObserver);\n      (_c = (_b = resizeHandler).cancel) === null || _c === void 0 ? void 0 : _c.call(_b);\n    };\n  }, [resizeHandler, refElement]);\n  useEffect(() => {\n    onResize === null || onResize === void 0 ? void 0 : onResize(size.width, size.height);\n  }, [size]);\n  return Object.assign({\n    ref: refProxy\n  }, size);\n}\nexport { useResizeDetector };","map":{"version":3,"names":["patchResizeCallback","resizeCallback","refreshMode","refreshRate","refreshOptions","debounce","throttle","useResizeDetector","skipOnMount","handleWidth","handleHeight","targetRef","observerOptions","onResize","skipResize","useRef","size","setSize","useState","width","undefined","height","refElement","setRefElement","current","setTimeout","refProxy","useMemo","Proxy","node","get","target","prop","set","value","shouldSetSize","useCallback","prevSize","nextSize","entries","forEach","entry","contentRect","resizeHandler","useEffect","resizeObserver","window","ResizeObserver","observe","_a","disconnect","call","_c","_b","cancel","Object","assign","ref"],"sources":["C:\\New folder\\timeline\\node_modules\\react-resize-detector\\src\\utils.ts","C:\\New folder\\timeline\\node_modules\\react-resize-detector\\src\\useResizeDetector.ts"],"sourcesContent":["import debounce from 'lodash/debounce';\nimport throttle from 'lodash/throttle';\nimport type { DebouncedFunc } from 'lodash';\n\nimport { Props } from './types';\n\nexport type PatchedResizeObserverCallback = DebouncedFunc<ResizeObserverCallback> | ResizeObserverCallback;\n\nexport const patchResizeCallback = (\n  resizeCallback: ResizeObserverCallback,\n  refreshMode: Props['refreshMode'],\n  refreshRate: Props['refreshRate'],\n  refreshOptions: Props['refreshOptions']\n): PatchedResizeObserverCallback => {\n  switch (refreshMode) {\n    case 'debounce':\n      return debounce(resizeCallback, refreshRate, refreshOptions);\n    case 'throttle':\n      return throttle(resizeCallback, refreshRate, refreshOptions);\n    default:\n      return resizeCallback;\n  }\n};\n","import { useEffect, useState, useRef, useCallback, useMemo } from 'react';\nimport type { DebouncedFunc } from 'lodash';\n\nimport { patchResizeCallback } from './utils';\n\nimport type {\n  OnRefChangeType,\n  ReactResizeDetectorDimensions,\n  UseResizeDetectorReturn,\n  useResizeDetectorProps\n} from './types';\n\nfunction useResizeDetector<T extends HTMLElement = any>({\n  skipOnMount = false,\n  refreshMode,\n  refreshRate = 1000,\n  refreshOptions,\n  handleWidth = true,\n  handleHeight = true,\n  targetRef,\n  observerOptions,\n  onResize\n}: useResizeDetectorProps<T> = {}): UseResizeDetectorReturn<T> {\n  const skipResize = useRef<boolean>(skipOnMount);\n\n  const [size, setSize] = useState<ReactResizeDetectorDimensions>({\n    width: undefined,\n    height: undefined\n  });\n\n  // we are going to use this ref to store the last element that was passed to the hook\n  const [refElement, setRefElement] = useState<T | null>(targetRef?.current || null);\n\n  // if targetRef is passed, we need to update the refElement\n  // we have to use setTimeout because ref get assigned after the hook is called\n  // in the future releases we are going to remove targetRef and force users to use ref returned by the hook\n  if (targetRef) {\n    setTimeout(() => {\n      if (targetRef.current !== refElement) {\n        setRefElement(targetRef.current);\n      }\n    }, 0);\n  }\n\n  // this is a memo that will be called every time the ref is changed\n  // This proxy will properly call setState either when the ref is called as a function or when `.current` is set\n  // we call setState inside to trigger rerender\n\n  const refProxy: OnRefChangeType<T> = useMemo(\n    () =>\n      new Proxy(\n        node => {\n          if (node !== refElement) {\n            setRefElement(node);\n          }\n        },\n        {\n          get(target, prop) {\n            if (prop === 'current') {\n              return refElement;\n            }\n            return target[prop];\n          },\n          set(target, prop, value) {\n            if (prop === 'current') {\n              setRefElement(value);\n            } else {\n              target[prop] = value;\n            }\n            return true;\n          }\n        }\n      ),\n    [refElement]\n  );\n\n  const shouldSetSize = useCallback(\n    (prevSize: ReactResizeDetectorDimensions, nextSize: ReactResizeDetectorDimensions) => {\n      if (prevSize.width === nextSize.width && prevSize.height === nextSize.height) {\n        // skip if dimensions haven't changed\n        return false;\n      }\n\n      if (\n        (prevSize.width === nextSize.width && !handleHeight) ||\n        (prevSize.height === nextSize.height && !handleWidth)\n      ) {\n        // process `handleHeight/handleWidth` props\n        return false;\n      }\n\n      return true;\n    },\n    [handleWidth, handleHeight]\n  );\n\n  const resizeCallback: ResizeObserverCallback = useCallback(\n    (entries: ResizeObserverEntry[]) => {\n      if (!handleWidth && !handleHeight) return;\n\n      if (skipResize.current) {\n        skipResize.current = false;\n        return;\n      }\n\n      entries.forEach(entry => {\n        const { width, height } = entry?.contentRect || {};\n        setSize(prevSize => {\n          if (!shouldSetSize(prevSize, { width, height })) return prevSize;\n          return { width, height };\n        });\n      });\n    },\n    [handleWidth, handleHeight, skipResize, shouldSetSize]\n  );\n\n  const resizeHandler = useCallback(patchResizeCallback(resizeCallback, refreshMode, refreshRate, refreshOptions), [\n    resizeCallback,\n    refreshMode,\n    refreshRate,\n    refreshOptions\n  ]);\n\n  // on refElement change\n  useEffect(() => {\n    let resizeObserver: ResizeObserver | undefined;\n    if (refElement) {\n      resizeObserver = new window.ResizeObserver(resizeHandler);\n      resizeObserver.observe(refElement, observerOptions);\n    } else {\n      if (size.width || size.height) {\n        setSize({ width: undefined, height: undefined });\n      }\n    }\n\n    return () => {\n      resizeObserver?.disconnect?.();\n      (resizeHandler as DebouncedFunc<ResizeObserverCallback>).cancel?.();\n    };\n  }, [resizeHandler, refElement]);\n\n  useEffect(() => {\n    onResize?.(size.width, size.height);\n  }, [size]);\n\n  return { ref: refProxy, ...size };\n}\n\nexport default useResizeDetector;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}